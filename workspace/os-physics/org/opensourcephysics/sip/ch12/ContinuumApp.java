/* Continuum Percolation  *//* last change 12/8/04 */package org.opensourcephysics.sip.ch12;import org.opensourcephysics.controls.*;import org.opensourcephysics.frames.*;import org.opensourcephysics.display.*;import java.awt.*;import java.awt.event.*;public class ContinuumApp extends AbstractCalculation implements InteractiveMouseHandler, Drawable  { PlottingPanel     plottingPanel = new PlottingPanel("x","y","  "); DrawingFrame      displayFrame = new DrawingFrame(plottingPanel); double[] x, y ;   // location for disks int[] colorOfDisk; // used for coloring clusters int N=0; int maxN;    //maximum number of disks double L; int clusterNumber;  // used to color clusterspublic ContinuumApp() {  displayFrame.addDrawable(this);}public void newSystem() {  L = control.getInt("Cell size");  maxN = (int)(10*L*L);  x = new double[maxN];  y = new double[maxN];  N = 0;  displayFrame.setPreferredMinMaxX(0,L);  displayFrame.setPreferredMinMaxY(0,L);  plottingPanel.setInteractiveMouseHandler(this);}public void handleMouseAction(InteractivePanel panel, MouseEvent evt) {  panel.handleMouseAction(panel, evt);  switch (panel.getMouseAction()) {    case InteractivePanel.MOUSE_PRESSED:      double ix= panel.getMouseX();      double iy= panel.getMouseY();      if (ix < 0 || iy < 0 || ix >= L || iy >= L)        return; // outside the lattice      else{        int i = foundDisk(ix,iy);        if(i > 0) {          clusterNumber++;          if(clusterNumber > 8) clusterNumber = 1;          colorCluster(i);          displayFrame.render();        }      }      break;  }}public void calculate() {  colorOfDisk = new int[maxN];  clusterNumber = 0;  double phi = control.getDouble("Occupied area fraction");  int numberToAdd = (int)(-4*L*L*Math.log(1.0-phi)/Math.PI) - N;  for(int i = N; i < N+numberToAdd; i++) {    x[i] = Math.random()*L;    y[i] = Math.random()*L;  }  N += numberToAdd;  displayFrame.render(); }public int foundDisk(double ix, double iy) {  for(int i = 0; i < N;i++) {     double dx = (ix - x[i]);     double dy = (iy - y[i]);     if(dx*dx+dy*dy < 1.0) return i;  }  return -1;}public void colorCluster(int i) {   colorOfDisk[i] = clusterNumber;   for(int j = 0; j < N; j++)      if((j!= i) && (colorOfDisk[j] == 0)) {         double dx = (x[j] - x[i]);         double dy = (y[j] - y[i]);         if(dx*dx+dy*dy < 1.0) colorCluster(j);  // recursive call      }}public void reset(){  control.setValue("Cell size", 30);  control.setValue("Occupied area fraction", 0.2); }public void draw (DrawingPanel myWorld, Graphics g) {    if(colorOfDisk == null) return;   	int pxRadius = Math.abs(myWorld.xToPix(0.5) - myWorld.xToPix(0));   	int pyRadius = Math.abs(myWorld.yToPix(0.5) - myWorld.yToPix(0));      for(int i = 0; i < N; i++) {        int xpix = myWorld.xToPix(x[i]) - pxRadius;        int ypix = myWorld.yToPix(y[i]) - pyRadius;        switch(colorOfDisk[i]) {          case 0: g.setColor(Color.black);break;          case 1: g.setColor(Color.red);break;          case 2: g.setColor(Color.green);break;          case 3: g.setColor(Color.blue);break;          case 4: g.setColor(Color.yellow);break;          case 5: g.setColor(Color.magenta);break;          case 6: g.setColor(Color.cyan);break;          case 7: g.setColor(Color.orange);break;          case 8: g.setColor(Color.pink);break;        }        g.fillOval(xpix, ypix, 2*pxRadius, 2*pyRadius);      }   g.setColor(Color.black);   int xpix = myWorld.xToPix(0);   int ypix = myWorld.yToPix(0);   int lx = myWorld.xToPix(L) - myWorld.xToPix(0);   int ly = myWorld.yToPix(L) - myWorld.yToPix(0);   g.drawRect(xpix,ypix,lx,ly);}public static void main(String args[]) {  CalculationControl control = CalculationControl.createApp(new ContinuumApp());  control.addButton("newSystem", "New System");}}
/* * The org.opensourcephysics.sip.ch11 package contains classes for chapter 11, * Random Processes, of the book Simulations in Physics. * Copyright (c) 2002  H. Gould, J. Tobochnik, and W. Christian. */package  org.opensourcephysics.sip.ch07;/* Attempt to simulate model in PRL 266103, vol. 91 (2003)  Jesper Ferkinghoff-Berg, Mogens H. JensenJoachim Mathiesen, Poul Olesen and Kim Sneppen, "Competition between Diffusion and Fragmentation: AnImportant Evolutionary Process of Nature"*/public class DiffusingObjects {   public int N[];  // N[L] = number of objects of length L   public int objects[];  // equivalent to walkers where length changes instead of walker position   public int mass;   public int initialLength;   public int steps = 0;   public int numberOfObjects;   public int DOverF;   public int minimumLength;   public int currentMass;   public void initialize() {      currentMass = mass;      N = new int[mass];      objects = new int[mass];      numberOfObjects = mass/initialLength;      for(int i = 0; i < numberOfObjects; i++)        objects[i] = initialLength;      N[initialLength] = numberOfObjects;      int remainingMass = mass - (numberOfObjects*initialLength);      if(remainingMass > 0) {        objects[numberOfObjects] = remainingMass;        numberOfObjects++;      }      steps = 0;     }   public void step() {     //diffusion     for(int n = 0; n < DOverF; n++)       for(int i = 0; i < numberOfObjects; i++)        if(Math.random() > 0.5) {       // potentially add to length          int j = (int)(Math.random()*numberOfObjects);          if((objects[j] > minimumLength) && (i != j)) {           int lengthOfI = objects[i];           int lengthOfJ = objects[j];           objects[i] += 1;           objects[j] -= 1;   // make sure total mass is conserved           N[lengthOfI]--;           N[lengthOfJ]--;           N[lengthOfI+1]++;           N[lengthOfJ-1]++;          }        }        else if(objects[i] > minimumLength) {           int j = (int)(Math.random()*numberOfObjects);           if(i != j) {            int lengthOfI = objects[i];            int lengthOfJ = objects[j];            objects[i] -= 1;            objects[j] += 1;   // make sure total mass is conserved            N[lengthOfI]--;            N[lengthOfJ]--;            N[lengthOfI-1]++;            N[lengthOfJ+1]++;           }        }     //fragmentation        int x = (int)(Math.random()*mass);   // choose random spot to fragment        int i = 0;        int sum = objects[i];        while(sum < x) {         // find object to fragment           i++;           sum += objects[i];        }        if(objects[i] > 2*minimumLength) {           int pieceA = 1 + (int)(Math.random()*(objects[i]-1));           int pieceB = objects[i] - pieceA;           if((pieceA >= minimumLength) && (pieceB >= minimumLength)) {             N[objects[i]]--;             objects[i] = pieceA;             objects[numberOfObjects] = pieceB;             N[pieceA]++;             N[pieceB]++;             numberOfObjects++;           }        }     steps++;   }}
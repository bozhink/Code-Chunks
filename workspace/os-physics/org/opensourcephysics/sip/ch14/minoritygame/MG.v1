package org.opensourcephysics.stp.minoritygame;public class MG {public int N = 101; // number of playerspublic int minority = N/2; // maximum number of agents to be in the minoritypublic int m; // length of memorypublic int nPast; // number of possible pastspublic int s = 2; // number of strategies for each agentpublic int nStep = 10000; // number of trials public int nRun = 32; // number of independent runspublic boolean strategies[][][];public int performance[][];public int agentValue[];public int chosenStrategy[];public int timeSeries[];public double sigma,spread;public int initial() {   // initialize for new game  minority = N/2;  nPast =1;  for(int i = 0; i < m;i++) nPast *= 2;  strategies = new boolean[N][s][nPast];  performance = new int[N][s];  agentValue = new int[N];  chosenStrategy = new int[N];  timeSeries = new int[nStep];  for (int i = 0; i < N; i++) {       for(int k = 0; k < nPast; k++) {          if(Math.random() < 0.5)             strategies[i][0][k] = true;          else            strategies[i][0][k] = false;        }        boolean same = true;        while (same) {             for(int k = 0; k < nPast; k++) {               if(Math.random() < 0.5)                    strategies[i][1][k] = true;               else                   strategies[i][1][k] = false;               if(strategies[i][1][k] != strategies[i][0][k]) same = false;              }          }    }            return (int)(Math.random()*nPast);}public void play() { boolean winner = false; sigma = 0; double sigma2 = 0; for(int iRun = 0; iRun < nRun;iRun++){  int past = initial();  double g = 0;  for(int iStep = 0; iStep < nStep; iStep++) {    int numberTrue = 0;    for (int i = 0; i < N; i++) {       if(performance[i][0] > performance[i][1])          chosenStrategy[i] = 0;       else if ((performance[i][0] < performance[i][1]))           chosenStrategy[i] = 1;       else       if (Math.random() > 0.5)  // tie, flip a coin          chosenStrategy[i] = 1;       else          chosenStrategy[i] = 0;       if(strategies[i][chosenStrategy[i]][past])numberTrue++;   // number of agents choosing true;    }// end for i    timeSeries[iStep] = numberTrue;    g += numberTrue;    if(numberTrue > minority)      winner = false;    else      winner = true;    for (int i = 0; i < N; i++) {      if(strategies[i][chosenStrategy[i]][past] == winner) agentValue[i]++;  // not used yet      if(strategies[i][0][past] == winner)performance[i][0]++;  // update performance       if(strategies[i][1][past] == winner)performance[i][1]++;  // for all strategies     }     // update past    past %= (nPast/2);  // eliminate "oldest" bit    past *= 2;            // shift bits over     if(winner)past++;           // add newest bit   }// end for iStep   double sumOfSquares = 0;   g /= 1.0*nStep;   for(int iStep = 0; iStep < nStep; iStep++)      sumOfSquares += Math.pow(timeSeries[iStep] - g, 2.0);   double sig = Math.sqrt(sumOfSquares/nStep);   sigma += sig;   sigma2 += sig*sig;  } // end for iRun sigma /= nRun; sigma2 /= nRun; spread = Math.sqrt(sigma2 - sigma*sigma); //spread of sigma values System.out.println(N +"\t" + m + "\t" + sigma2/N + "\t" + (1.0*nPast)/N); // data needed to see scaling behavior}         }
package org.opensourcephysics.sip.ch15.clustering;import org.opensourcephysics.display.*;import org.opensourcephysics.display2d.*;import java.awt.*;public class Cluster implements Drawable {   public int [] spin,n;   public double [][] J;  //coupling to 5 nearest neighbors   public int [][] neighbor;  // 5 nearest neighbors   public Circle [] disk; // position of spins   public double L;   public double temperature,beta;   public int N,q=12;   public int mcs = 0;  // number of MC moves per spin   public int energy;   public double energyAccumulator = 0;   public double energySquaredAccumulator = 0;   public double magnetization = 0;   public double magnetizationAccumulator = 0;   public double magnetizationSquaredAccumulator = 0;   public int acceptedMoves = 0;   public void initialize() {     N = 200;     disk = new Circle[N];     spin = new int[N];     n = new int[q];     setPositions();     for (int i = 0; i < N; ++i) {            spin[i] = (int)(Math.random()*q);  // random spins            n[spin[i]]++;     }     J = new double[N][5];     neighbor = new int[N][5];     findNeighbors();     resetData();     beta = 1.0/temperature;   }           public void setPositions() {     int pixRadius = 1;     double r2,x,y;     for(int i = 0; i < 40; i++) {   // low density square region        x = 5.0 + 4*(Math.random() - 0.5);        y = 5.0 + 4*(Math.random() - 0.5);        disk[i] = new Circle(x,y, pixRadius);     }     for(int i = 40; i < 120; i++) {  // high density circular region       do{        x = 11.0 + 4*(Math.random() - 0.5);        y = 11.0 + 4*(Math.random() - 0.5);        double dx = (x - 11.0);        double dy = (y - 11.0);        r2 = dx*dx + dy*dy;       }       while(r2 > 2.0);       disk[i] = new Circle(x,y, pixRadius);     }     for(int i = 120; i < 160; i++) {  //rectangular region        x = 7.0 + 5*(Math.random());        y = 2.0 + 2*(Math.random());        disk[i] = new Circle(x,y, pixRadius);     }     for(int i = 160; i < 200; i++) {  //no region        x = L*Math.random();        y = L*Math.random();        disk[i] = new Circle(x,y, pixRadius);     }   }         public void findNeighbors() {      double largestR2[] = new double[N];      int largestSpin[] = new int[N];      for(int i = 0; i < N; i++) {  // set random neighbors        largestR2[i] = 0;        for(int j = 0; j < 5; j++) {           int nn = (i + j + 1) % N;           neighbor[i][j] = nn;           double dx = (disk[i].getX() - disk[nn].getX());           double dy = (disk[i].getY() - disk[nn].getY());           J[i][j] = dx*dx + dy*dy;  // first compute distance squared           if(J[i][j] > largestR2[i]) {              largestR2[i] = J[i][j];              largestSpin[i] = j;           }        }      }      for(int i = 0; i < N; i++) {  // find nearest 5 neighbors        for(int j = 0; j < N; j++) {           if(i != j){            double dx = (disk[i].getX() - disk[j].getX());            double dy = (disk[i].getY() - disk[j].getY());            double r2 = dx*dx + dy*dy;             if(r2 < largestR2[i]) {      // new nearest neighbor              neighbor[i][largestSpin[i]] = j;              J[i][largestSpin[i]] = r2;              largestR2[i] = r2;              for(int k = 0; k < 5;k++) {                 if(J[i][k] > largestR2[i]) {                    largestSpin[i] = k;                    largestR2[i] = J[i][k];                 }              }           }       }      }    }    double twoASquared = 8.0;    for(int i = 0; i < N; i++) {        for(int j = 0; j < 5; j++) {          J[i][j] = 0.5*Math.exp(-J[i][j]/twoASquared);        }    } }   public double susceptibility() {      double magnetizationSquaredAverage = magnetizationSquaredAccumulator/mcs;      double magnetizationAverage = magnetizationAccumulator/mcs;      return (magnetizationSquaredAverage - Math.pow(magnetizationAverage,2));   }   public void resetData() {      mcs = 0;      energyAccumulator = 0;      energySquaredAccumulator = 0;      magnetizationAccumulator = 0;      magnetizationSquaredAccumulator = 0;      acceptedMoves = 0;   }   public void doOneMCStep() {      for (int k = 0; k < N; ++k) {         int i = (int)(Math.random()*N);         int trialSpin = (1 + spin[i]  + (int)(Math.random()*(q-1))) % q;         double dE = computeDE(i,trialSpin);         if ((dE <= 0) || (Math.exp(-beta*dE) > Math.random())) {            n[spin[i]]--;            n[trialSpin]++;            spin[i] = trialSpin;            acceptedMoves++;         }      }      int nMax = 0;      for(int i = 0; i < q; i++) {         if(n[i] > nMax) {           nMax = n[i];         }      }      magnetization = (((1.0*q*nMax)/N) - 1.0)/(q - 1.0);      magnetizationAccumulator += magnetization;      magnetizationSquaredAccumulator += magnetization*magnetization;      mcs++;   }      public double computeDE(int i, int trialSpin) {      double dE = 0;      for(int j = 0; j < 5; j++) {         if(spin[neighbor[i][j]] == trialSpin) dE -= J[i][j];         if(spin[neighbor[i][j]] == spin[i]) dE += J[i][j];      }      return dE;   }         public void draw (DrawingPanel panel, Graphics g) {      if(spin==null) return;      for(int i = 0; i < N; i++) {        switch(spin[i]) {           case 0: disk[i].color = Color.black;break;          case 1: disk[i].color = Color.blue;break;          case 2: disk[i].color = Color.cyan;break;          case 3: disk[i].color = Color.darkGray;break;          case 4: disk[i].color = Color.gray;break;          case 5: disk[i].color = Color.green;break;          case 6: disk[i].color = Color.lightGray;break;          case 7: disk[i].color = Color.magenta;break;          case 8: disk[i].color = Color.orange;break;          case 9: disk[i].color = Color.pink;break;          case 10: disk[i].color = Color.red;break;          case 11: disk[i].color = Color.yellow;break;       }       disk[i].draw(panel,g);     } }}
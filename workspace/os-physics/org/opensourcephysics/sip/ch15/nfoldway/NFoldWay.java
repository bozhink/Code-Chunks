package org.opensourcephysics.sip.ch15.nfoldway;import org.opensourcephysics.display.*;import org.opensourcephysics.display2d.*;import java.awt.*;public class NFoldWay implements Drawable {   public static final double criticalTemperature = 2.0/Math.log(1.0 + Math.sqrt(2.0));   public int [] spin,spinClass,spinIndex;   public int [][] spinInClass;  // lists spin in each class   public int L = 32;   public int N = L*L;   public double temperature = criticalTemperature;   public double field;   public double energy;   public double energyAccumulator = 0;   public double energySquaredAccumulator = 0;   public int magnetization = 0;   public double magnetizationAccumulator = 0;   public double magnetizationSquaredAccumulator = 0;   private double [] w = new double[10];  // array to hold Boltzmann factors   private int [] nq = new int[10];  // number of spins in each class   public double qSum,totalTime;   private CellLattice lattice;   public int mcs;    public void initialize(int _L) {      L=_L;      N = L*L;      lattice = new CellLattice(L,L);         // only used for drawing       lattice.setIndexedColor(0, Color.red);         lattice.setIndexedColor(2, Color.green);      spin = new int[N];      spinIndex = new int[N];      spinClass = new int[N];      spinInClass = new int[N][10];      for (int i = 0; i < N; ++i) {            spin[i] = 1;  // all spins up |spin[i]| gives index in spinInClass array            spinInClass[i][9] = i;            spinClass[i] = 9;            spinIndex[i] = i;      }      magnetization = N;      energy = -2*N -N*field;      for(int spin = -1; spin <= 1; spin += 2) {  //spin = -1 or 1        for(int localField = -4; localField <= 4; localField += 2) {//field of 4 neighbors           int classLabel = ((localField+4)/2) + ((spin+1)/2)*5;           w[classLabel] = Math.exp(-2.0*spin*(localField + field)/temperature);           if(w[classLabel] > 1) w[classLabel] = 1.0; // Metropolis dynamics           nq[classLabel] = 0;        }      }      nq[9] = N;      qSum = nq[9]*w[9];      totalTime = 0;      resetData();   }   public double specificHeat() {      double energySquaredAverage = energySquaredAccumulator/totalTime;      double energyAverage = energyAccumulator/totalTime;      double heatCapacity = energySquaredAverage - energyAverage*energyAverage;      heatCapacity = heatCapacity/(temperature*temperature);      return (heatCapacity/N);   }   public double susceptibility() {      double magnetizationSquaredAverage = magnetizationSquaredAccumulator/totalTime;      double magnetizationAverage = magnetizationAccumulator/totalTime;      return (magnetizationSquaredAverage - Math.pow(magnetizationAverage,2))/(temperature*N);   }   public void resetData() {      totalTime = 0;      energyAccumulator = 0;      energySquaredAccumulator = 0;      magnetizationAccumulator = 0;      magnetizationSquaredAccumulator = 0;      mcs = 0;   }   public void doOneMCStep() {      for (int k = 0; k < N; ++k) {         double dt = -(N/qSum)*Math.log(Math.random());         energyAccumulator += energy*dt;         energySquaredAccumulator += energy*energy*dt;         magnetizationAccumulator += magnetization*dt;         magnetizationSquaredAccumulator += magnetization*magnetization*dt;         totalTime += dt;         double qPart = Math.random()*qSum;         int classLabel = 0;         double qAccum = nq[0]*w[0];         while(qAccum < qPart) {   // find class of spin to flip           classLabel++;           qAccum += nq[classLabel]*w[classLabel];         }         //flip spin         int index = (int)(Math.random()*nq[classLabel]);         int i = spinInClass[index][classLabel];         int newClassLabel = classLabel + 5;         if(newClassLabel > 9) newClassLabel -= 10;         spinInClass[index][classLabel] =  spinInClass[nq[classLabel]-1][classLabel]; //remove spin from old class         spinIndex[spinInClass[nq[classLabel]-1][classLabel]] = index;         nq[classLabel]--;         spinInClass[nq[newClassLabel]][newClassLabel] = i;         spin[i] = -spin[i];         spinIndex[i] = nq[newClassLabel];           nq[newClassLabel]++;         spinClass[i] = newClassLabel;         qSum += w[newClassLabel] - w[classLabel];         //update neighbors         int iy = i/L;   // row         int ix = i - L*iy;  // column         int right = ((ix+1) %L) + L*iy;         int left = ((ix-1+L) %L) + L*iy;         int above = ((iy+1)%L)*L + ix;         int below = ((iy-1+L)%L)*L + ix;         if(spin[i] == 1) { // new spin up old spin down, means local field of neighbors increases            adjustClass(right,1);            adjustClass(left,1);            adjustClass(above,1);            adjustClass(below,1);         }         else {            adjustClass(right,-1);            adjustClass(left,-1);            adjustClass(above,-1);            adjustClass(below,-1);         }         energy += -2*spin[i]*(spin[right] + spin[left] + spin[above] + spin[below] + field);         magnetization += 2*spin[i];         }         mcs++;      }           public void adjustClass(int i, int localFieldChange) {      int classLabel = spinClass[i];      int index = spinIndex[i];       int newClassLabel = classLabel + localFieldChange;       //System.out.println(classLabel + " " + index + " " + newClassLabel);      //System.out.println(" " + nq[classLabel] + " " + nq[newClassLabel]);      spinInClass[index][classLabel] =  spinInClass[nq[classLabel]-1][classLabel]; //remove spin from old class      spinIndex[spinInClass[nq[classLabel]-1][classLabel]] = index;      nq[classLabel]--;      spinInClass[nq[newClassLabel]][newClassLabel] = i;      spinIndex[i] = nq[newClassLabel];        nq[newClassLabel]++;      spinClass[i] = newClassLabel;      qSum += w[newClassLabel] - w[classLabel];  }         public void draw (DrawingPanel panel, Graphics g) {      if(lattice==null) return;      for(int i = 0; i < N; i++) {         int iy = i/L;   // row         int ix = i - L*iy;  // column         lattice.setValue(ix,iy,(byte)(spin[i]+1));      }      lattice.draw(panel,g);   }}
package org.opensourcephysics.sip.ch06;import org.opensourcephysics.controls.*;import org.opensourcephysics.frames.*;/** * @author Jan Tobochnik */public class MeasuringChaosApp extends AbstractSimulation {  PlotFrame 		plotFrame = new PlotFrame("n", "ln zi", "Data");  double dx0,xSep,q, a;  int numberOfIterations,n;  double dataAccum[];  /**   * Initializes the animation using the values in the control.   *   */  public void initialize() {    dx0 = control.getDouble("dx0");    numberOfIterations = control.getInt("numberOfIterations");    q = control.getDouble("q");    a = control.getDouble("a");    dataAccum = new double[numberOfIterations];    n = 2;    xSep = 1.0;  }  /**   * Steps the time.   */  public void doStep() {    plotFrame.clearData();    double oneMinusQ = 1.0 - q;    for(int i = 0; i < n; i += 2) {       double x1 = -1.0 + xSep*(i+1);       double x2 = x1 + dx0;       double dx = dx0;       for(int t = 0; t < numberOfIterations; t++) {         if(q == 1.0) {           dx = -a*dx*(x1+x2);           x1 = 1.0 - a*x1*x1;           x2 = 1.0 - a*x2*x2;           dataAccum[t] += Math.log(Math.abs(dx)/dx0);           }         else {          dx = -a*dx*(x1+x2);          x1 = 1.0 - a*x1*x1;          x2 = 1.0 - a*x2*x2;          dataAccum[t] += (Math.pow(Math.abs(dx)/dx0,oneMinusQ) - 1)/oneMinusQ;         }       }    }    for(int t = 0; t < numberOfIterations; t++) {        plotFrame.append(0,t+1,dataAccum[t]/(n-1));    }    n *= 2;    xSep /= 2.0;    plotFrame.setMessage("n = " + n);  }    /**   * Resets animation to a predefined state.   */  public void reset() {    control.setValue("dx0",0.000001);    control.setValue("numberOfIterations",50);    control.setValue("q",0.36);    control.setValue("a",1.401155189);  }  /**   * Start Java application.   * @param args  command line parameters   */  public static void main(String[] args) {     SimulationControl.createApp(new MeasuringChaosApp());   }}
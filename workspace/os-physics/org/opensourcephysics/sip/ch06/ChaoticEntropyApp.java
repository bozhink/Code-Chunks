package org.opensourcephysics.sip.ch06;import org.opensourcephysics.controls.*;import org.opensourcephysics.frames.*;/** * @author Jan Tobochnik, revised 12/21/04 */public class ChaoticEntropyApp extends AbstractSimulation {  PlotFrame 	    plotFrame = new PlotFrame("t", "entropy", "Data");  double dx,q,a;  int numberOfIterations,numberOfTrials,numberOfBins,numberOfPoints;  int p[][];  double entropyAccumulator[];  /**   * Initializes the animation using the values in the control.   *   */  public void initialize() {    numberOfBins = control.getInt("numberOfBins");    numberOfIterations = control.getInt("numberOfIterations");    q = control.getDouble("q");    a = control.getDouble("a");    entropyAccumulator = new double[numberOfIterations];    dx = 2.0/numberOfBins;    numberOfTrials = 0;  }  /**   * Steps the time.   */  public void doStep() {    plotFrame.clearData();    numberOfPoints = control.getInt("number of points");    for(int step = 0; step < control.getInt("steps between plots"); step++) {      double x0 = -1 + 2.0*Math.random();       p = new int[numberOfBins+1][numberOfIterations];      for(int i = 0; i < numberOfPoints; i++) {        double x = x0 + Math.random()*dx;        for(int t = 0; t < numberOfIterations; t++) {          x = 1.0 - a*x*x;          p[(int)(0.5*numberOfBins*(x+1))][t]++;        }      }      numberOfTrials++;      for(int t = 0; t < numberOfIterations; t++) {       entropyAccumulator[t] += entropy(t);      }    }    for(int t = 0; t < numberOfIterations; t++) {       plotFrame.append(1,t+1,entropyAccumulator[t]/numberOfTrials);    }    plotFrame.setMessage("numberOfTrials = " + numberOfTrials);      }    public double entropy(int t) {    double sum = 0;    if(q == 1.0) {      for(int i = 0; i <= numberOfBins; i++) {        if(p[i][t] > 0) {         double p_i = (1.0*p[i][t])/numberOfPoints;         if(p_i > 0) sum -= p_i*Math.log(p_i);         }      }      return sum;    }    else {      for(int i = 0; i <= numberOfBins; i++) {        if(p[i][t] > 0) {         double p_i = (1.0*p[i][t])/numberOfPoints;         sum += Math.pow(p_i,q);        }       }      return (1.0-sum)/(q - 1.0);   }  }  /**   * Resets animation to a predefined state.   */  public void reset() {    control.setValue("numberOfBins",1000);    control.setValue("numberOfIterations",50);    control.setValue("q",0.36);    control.setValue("a",1.401155189);    control.setValue("number of points",10000);    control.setValue("steps between plots",10);  }  /**   * Start Java application.   * @param args  command line parameters   */  public static void main(String[] args) {     SimulationControl.createApp(new ChaoticEntropyApp());  }}
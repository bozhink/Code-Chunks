package org.opensourcephysics.sip.ch13.percolation.invasion;import org.opensourcephysics.display.*;import java.awt.*;public class Invasion implements Drawable{public int Lx,Ly;public double s[][];public int perimeterListX[],perimeterListY[];public int numberOfPerimeterSites;public boolean ok = true;public void createNewLattice() {   Lx = 2*Ly;   s = new double[Lx][Ly];   perimeterListX = new int[Lx*Ly];   perimeterListY = new int[Lx*Ly];   for(int y = 0; y < Ly; y++)      s[0][y] = 1;   // occupy first column   for(int y = 0; y < Ly; y++)     for(int x = 1; x < Lx; x++)      s[x][y] = Math.random();   numberOfPerimeterSites = 0;   for(int y = 0; y < Ly; y++) {  //second column are perimeter sites      s[2][y] += 2;   // perimeter sites have s > 2;      numberOfPerimeterSites++;      insert(2,y);  // insert site in perimeter list in order.    }    ok = true;}public void insert(int x, int y) {   int insertionLocation = binarySearch(x,y);   for(int i = numberOfPerimeterSites-1; i > insertionLocation; i--) {      perimeterListX[i] = perimeterListX[i-1];      perimeterListY[i] = perimeterListY[i-1];   }   perimeterListX[insertionLocation] = x;   perimeterListY[insertionLocation] = y;}public int binarySearch(int x, int y) {   int firstLocation = 0;   int lastLocation = numberOfPerimeterSites-2;   if(lastLocation < 0) lastLocation = 0;   int middleLocation = (firstLocation + lastLocation)/2;   // determine which half of list new number is in   while(lastLocation - firstLocation > 1) {      int middleX = perimeterListX[middleLocation];      int middleY = perimeterListY[middleLocation];      if(s[x][y] > s[middleX][middleY])         lastLocation = middleLocation;      else         firstLocation = middleLocation;      middleLocation = (firstLocation + lastLocation)/2;   }   return lastLocation;}public void step() {   if(ok) {    int nx[] = {1,-1,0,0};    int ny[] = {0,0,1,-1};    int x = perimeterListX[numberOfPerimeterSites-1];    int y = perimeterListY[numberOfPerimeterSites-1];    if(x > Lx -3) ok = false;    numberOfPerimeterSites--;    s[x][y] -= 1;    for(int i = 0; i < 4;i++) {  // find new perimeter sites        int perimeterX = x + nx[i];        int perimeterY = (y + ny[i]) % Ly;        if(perimeterY == -1) perimeterY = Ly-1;        if(s[perimeterX][perimeterY] < 1)  {  // new perimeter site           s[perimeterX][perimeterY] += 2;           numberOfPerimeterSites++;           insert(perimeterX,perimeterY);        }     }    }}public void computeDistribution(DatasetManager dm) {    int numberOfBins = 20;    int numberOccupied = 0;    double occupied[] = new double[numberOfBins];    double number[] = new double[numberOfBins];    double binSize = 1.0/numberOfBins;    int minX = Lx/3;    int maxX = 2*minX;    for(int x = minX; x <= maxX; x++)       for(int y = 0; y < Ly; y++) {          int bin = (int)(numberOfBins*(s[x][y] % 1));          number[bin]++;          if((s[x][y] >= 1) && (s[x][y] < 2)){            numberOccupied++;            occupied[bin]++;          }       }    System.out.println("Number occupied = " + numberOccupied);    for(int bin = 0; bin < numberOfBins; bin++)        dm.append(0,(bin+0.5)*binSize, occupied[bin]/number[bin]);}public void draw (DrawingPanel myWorld, Graphics g) {  if(s == null) return;  int sizeX = Math.abs(myWorld.xToPix(0.8) - myWorld.xToPix(0));  int sizeY = Math.abs(myWorld.yToPix(0.8) - myWorld.yToPix(0));  for(int i = 0; i < Lx; i++)   for(int j = 0; j < Ly; j++) {    switch ((int)s[i][j]) {    case 0: g.setColor(Color.white);break;    case 1: g.setColor(Color.black);break;    case 2: g.setColor(Color.yellow);break;   }    int xpix = myWorld.xToPix(i) - sizeX;    int ypix = myWorld.yToPix(j) - sizeY;    g.fillRect(xpix,ypix,sizeX,sizeY);  }}}
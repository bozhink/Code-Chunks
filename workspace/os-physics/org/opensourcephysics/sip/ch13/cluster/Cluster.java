/*  Creates percolation cluster with probability p and computes mass distribution */package  org.opensourcephysics.sip.ch13.cluster;import java.awt.Color;import java.awt.Graphics;import org.opensourcephysics.display.Drawable;import org.opensourcephysics.display.DrawingPanel;public class Cluster implements Drawable{		public int s[][];	public int xs[],ys[],pxs[],pys[];	public int L;	public double p;  //site occupation probability	int occupiedNumber;	int perimeterNumber;	int nx[] = {1,-1,0,0};	int ny[] = {0,0,1,-1};	double mass[];public void initialize() {    s = new int[L+2][L+2];    xs = new int[L*L];  //location of occupied sites    ys = new int[L*L];    pxs = new int[L*L];  //location of perimeter sites    pys = new int[L*L];    for(int i = 0; i < L+2; i++) {       s[0][i] = -1;        // don't occupy edge sites       s[L+1][i] = -1;        s[i][0] = -1;        s[i][L+1] = -1;     }    xs[0] = 1 + (L/2);    ys[0] = xs[0];    s[xs[0]][ys[0]] = 1;   // occupy center site    occupiedNumber = 1;    for(int n = 0; n < 4; n++) {  // perimeter sites       pxs[n] = xs[0] + nx[n];       pys[n] = ys[0] + ny[n];       s[pxs[n]][pys[n]] = 2;    }    perimeterNumber = 4;}public void step() {  if(perimeterNumber > 0) {    int perimeter = (int)(Math.random()*perimeterNumber);    int x = pxs[perimeter];    int y = pys[perimeter];    perimeterNumber--;    pxs[perimeter] = pxs[perimeterNumber];    pys[perimeter] = pys[perimeterNumber];    if(Math.random() < p ) {   //occupy site      s[x][y] = 1;      xs[occupiedNumber] = x;      ys[occupiedNumber] = y;      occupiedNumber++;      for(int n = 0; n < 4; n++) {  // find new perimeter sites        int px = x + nx[n];        int py = y + ny[n];        if(s[px][py] == 0) {            pxs[perimeterNumber] = px;          pys[perimeterNumber] = py;          s[px][py] = 2;          perimeterNumber++;        }      }    }    else       s[x][y] = -1;    } } public void massDistribution() {   mass = new double[L];   double xcm = 0;   double ycm = 0;   for(int n = 0; n < occupiedNumber; n++) {       xcm += xs[n];     ycm += ys[n];   }   xcm /= occupiedNumber;   ycm /= occupiedNumber;   for(int n = 0; n < occupiedNumber; n++) {       double dx = xs[n] - xcm;     double dy = ys[n] - ycm;     int r = (int)Math.sqrt(dx*dx + dy*dy);     if((r > 1) && (r < L)) mass[r]++;   }} public void draw (DrawingPanel myWorld, Graphics g) {  if(s == null) return;  int sizeX = Math.abs(myWorld.xToPix(0.8) - myWorld.xToPix(0));  int sizeY = Math.abs(myWorld.yToPix(0.8) - myWorld.yToPix(0));  for(int i = 1; i < L+1; i++)    for(int j = 1; j < L+1; j++) {    int xpix = myWorld.xToPix(i) - sizeX;    int ypix = myWorld.yToPix(j) - sizeY;    switch (s[i][j]) {    case 0:      g.setColor(Color.black);     g.fillRect(xpix + sizeX/2,ypix + sizeY/2,1,1);     break;    case 1:      g.setColor(Color.blue);      g.fillOval(xpix,ypix,sizeX,sizeY);      break;    case -1:      g.setColor(Color.yellow);      g.fillOval(xpix,ypix,sizeX,sizeY);      break;    case 2:      g.setColor(Color.green);      g.fillOval(xpix,ypix,sizeX,sizeY);      break;     }  }}}  